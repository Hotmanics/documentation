---
section: ccip
date: Last Modified
title: "Optimizing Gas Limit Settings in CCIP Messages for Receiver Execution"
---

When constructing a [CCIP message](/ccip/api-reference/client#evm2anymessage), accurately setting the gas limit is crucial. The gas limit represents the maximum amount of gas that can be consumed to execute the [ccipReceive](/ccip/api-reference/ccip-receiver#ccipreceive) function on the CCIP Receiver, fundamentally influencing the transaction fees for sending a CCIP message. Notably, unused gas is not reimbursed, making it essential to estimate the gas limit carefully:

- Setting the gas limit too low will cause the transaction to revert when CCIP calls `ccipReceive` of the CCIP Receiver, necessitating a manual re-execution with an increased gas limit. For further details, refer to the [manual execution guide](/ccip/tutorials/manual-execution).
- Conversely, an excessively high gas limit leads to higher fees.

This tutorial will guide you through estimating the gas limit for the `ccipReceive` function using various methods. We will explore using a CCIP Receiver, where the gas consumption of the `ccipReceive` function varies based on the input data, emphasizing the need for testing under diverse conditions. Our examination will span across different environments:

1. **Local Environment**: Utilizing [Hardhat](https://hardhat.org/) and [Foundry](https://book.getfoundry.sh/) on a local blockchain provides a swift initial gas estimate. However, different frameworks can yield different results. Moreover, the local environment will not always be representative of your destination blockchain. Consider these figures preliminary estimates, then incorporate a buffer and conduct subsequent validations on a testnet.
1. **Testnet**: By deploying your CCIP Sender and Receiver on a testnet and transmitting several CCIP messages with the previously estimated gas, you can precisely determine the necessary gas limit. Although this approach is more time-intensive, especially if testing across multiple blockchains, it offers enhanced accuracy.
1. **Offchain Methods**: Estimating gas using an offchain web3 provider or tools like [Tenderly](https://docs.tenderly.co/) represents the most accurate and rapid method to determine the needed gas limit.

These approaches will give you insights into accurately estimating the gas limit for the `ccipReceive` function, ensuring cost-effective CCIP transactions.

Before you begin, open a terminal clone the [smart-contract-examples repository](https://github.com/smartcontractkit/smart-contract-examples) and change to the `smart-contract-examples/ccip/estimate-gas` directory.

    ```shell
    git clone https://github.com/smartcontractkit/smart-contract-examples.git && \
    cd smart-contract-examples/ccip/estimate-gas
    ```

## Examine the code

The CCIP Sender and Receiver source codes are in the contracts directory for Hardhat projects and the src directory for Foundry projects. The code is structured to be self-explanatory, complemented by comprehensive comments to explain the functionality of each function. This section will focus on the `_ccipReceive` function:

```solidity
function _ccipReceive(Client.Any2EVMMessage memory any2EvmMessage) internal override {
  uint256 iterations = abi.decode(any2EvmMessage.data, (uint256));

  uint256 result = iterations;
  uint256 maxIterations = iterations % 100;
  for (uint256 i = 0; i < maxIterations; i++) {
    result += i;
  }

  emit MessageReceived(
    any2EvmMessage.messageId,
    any2EvmMessage.sourceChainSelector,
    abi.decode(any2EvmMessage.sender, (address)),
    iterations,
    maxIterations,
    result
  );
}
```

The `_ccipReceive` function's breakdown is as follows:

1. **Input Processing:** The function accepts a `Client.Any2EVMMessage`.The first step involves decoding the number of iterations from the message's data using ABI decoding.
1. **Logic Execution:** It initializes the result variable with the number of iterations. The function calculates `maxIterations` by taking the modulo of iterations with 100, setting an upper limit for iteration. This precautionary step ensures that the function will not run out of gas.
1. **Iteration:** The function iterates from 0 to `maxIterations`. This loop simulates the variable computational work based on the input data, which, in turn, affects gas consumption.
1. **Event Emission:** Finally, an event MessageReceived is emitted.

This code shows how gas consumption for the `_ccipReceive` function can fluctuate in response to the input data, highlighting the necessity for thorough testing under different scenarios to determine the correct `gasLimit`.

## Gas estimation in a local environment

To facilitate testing within a local environment, you will use the [MockCCIPRouter](https://github.com/smartcontractkit/ccip/blob/ccip-develop/contracts/src/v0.8/ccip/test/mocks/MockRouter.sol) contract. This contract serves as a mock implementation of the CCIP Router contract, enabling the local testing of CCIP Sender and Receiver contracts.
A notable feature of the `MockCCIPRouter` contract is its ability to emit a `MsgExecuted` event:

```solidity
event MsgExecuted(bool success, bytes retData, uint256 gassed))
```

This event reports the amount of gas consumed by the `ccipReceive` function.

### Foundry

#### Prerequisites

1. In tour terminal, change to the `foundry` directory:

   ```shell
   cd foundry
   ```

1. Make sure Foundry is [installed](https://book.getfoundry.sh/getting-started/installation) or run `foundryup` to update Foundry.

1. Check the Foundry version:

   ```shell
   forge --version
   ```

   The output should be similar to (version 0.2.0 or above):

   ```text
   forge 0.2.0 (545cd0b 2024-03-14T00:20:00.210934000Z)
   ```

1. Build your project:

   ```shell
   forge build
   ```

   The output should be similar to:

   ```text
   [⠊] Compiling...
   [⠔] Compiling 52 files with 0.8.19
   [⠑] Solc 0.8.19 finished in 2.55s
   Compiler run successful!
   ```

#### Estimate gas

The test file named `SendReceive.t.sol`, located within the `test` directory, is designed to evaluate the gas usage of the ccipReceive function. This file includes a test case that transmits a CCIP message to the `MockCCIPRouter` contract, triggering the `MsgExecuted` event. This event provides insights into the gas requirements of the `ccipReceive` function by detailing the amount of gas utilized. The test case has three different scenarios, each varying by the number of iterations to comprehensively understand gas consumption under various conditions:

- **`0` iterations:** This scenario aims to determine the baseline gas consumption, representing the least amount of gas required.
- **`50` iterations:** This scenario estimates the gas consumption under average operational conditions.
- **`99` iterations:** This final scenario estimates the peak gas consumption, marking the upper limit of gas usage.

To run the test, execute the following command:

```shell
forge test -vv --isolate
```

Example of the output:

```text
[⠊] Compiling...
[⠘] Compiling 52 files with 0.8.19
[⠃] Solc 0.8.19 finished in 2.72s
Compiler run successful!

Ran 3 tests for test/SendReceive.t.sol:SenderReceiverTest
[PASS] test_SendReceiveAverage() (gas: 125166)
Logs:
  Number of iterations 50 - Gas used: 14740

[PASS] test_SendReceiveMax() (gas: 134501)
Logs:
  Number of iterations 99 - Gas used: 24099

[PASS] test_SendReceiveMin() (gas: 115581)
Logs:
  Number of iterations 0 - Gas used: 5190

Suite result: ok. 3 passed; 0 failed; 0 skipped; finished in 10.84ms (5.28ms CPU time)

Ran 1 test suite in 188.81ms (10.84ms CPU time): 3 tests passed, 0 failed, 0 skipped (3 total tests)
```

This table summarizes the gas usage for different iterations:

| Number of iterations | Gas used |
| -------------------- | -------- |
| 0                    | 5190     |
| 50                   | 14740    |
| 99                   | 24099    |

As you can notice from the output, the gas usage increases with the number of iterations. The upper limit is observed when the number of iterations is 99.
In the next section, you will compare these results with the ones obtained from a local Hardhat environment.

### Hardhat

#### Prerequisites

1. In your terminal, change to the `hardhat` directory:

   ```shell
   cd hardhat
   ```

1. Install the dependencies:

   ```shell
   npm install
   ```

1. Set the password to encrypt your environment variables using the following command:

```bash
npx env-enc set-pw
```

1. Set up the following environment variables (These variables will be used to deploy your contracts on testnets):

   - `PRIVATE_KEY`: Find the private key for your testnet wallet. If you use MetaMask, follow the instructions to [Export a Private Key](https://support.metamask.io/hc/en-us/articles/360015289632-How-to-export-an-account-s-private-key). **Note:** Your private key is needed to sign any transactions you make such as making requests.
   - `ETHEREUM_SEPOLIA_RPC_URL`: The RPC URL for Ethereum Sepolia testnet. You can sign up for a personal endpoint from [Alchemy](https://www.alchemy.com/), [Infura](https://www.infura.io/), or another node provider service.
   - `AVALANCHE_FUJI_RPC_URL`: The RPC URL for Avalanche Fuji testnet. You can sign up for a personal endpoint from [Alchemy](https://www.alchemy.com/), [Infura](https://www.infura.io/), or another node provider service.
   - `ETHERSCAN_API_KEY`: An Ethereum explorer API key, used to verify your contract. Follow [this guide](https://docs.etherscan.io/getting-started/viewing-api-usage-statistics) to get one.

Input these variables using the following command:

```bash
npx env-enc set
```

1. Compile the contracts:

   ```shell
   npx hardhat compile
   ```

   The output should be similar to:

   ```text
   Generating typings for: 31 artifacts in dir: typechain-types for target: ethers-v6
   Successfully generated 114 typings!
   Compiled 33 Solidity files successfully (evm target: paris).
   ```

#### Estimate gas

The test file named `Send-Receive.ts`, located within the `test` directory, is designed to evaluate the gas usage of the `ccipReceive` function. This file employs the same logic as the Foundry test file, featuring three scenarios varying by the number of iterations. The test case transmits a CCIP message to the `MockCCIPRouter` contract, triggering the `MsgExecuted` event. This event provides insights into the gas requirements of the `ccipReceive` function by detailing the amount of gas utilized.

To run the test, execute the following command:

```shell
npx hardhat test
```

Example of the output:

```text
  Sender and Receiver
Final Gas Usage Report:
Number of iterations 0 - Gas used: 5168
Number of iterations 50 - Gas used: 14718
Number of iterations 99 - Gas used: 24077
    ✔ should CCIP message from sender to receiver (1716ms)


  1 passing (2s)
```

This table summarizes the gas usage across different iterations:

| Number of iterations | Gas used |
| -------------------- | -------- |
| 0                    | 5168     |
| 50                   | 14718    |
| 99                   | 24077    |

As you can notice from the output, the gas usage increases with the number of iterations. The upper limit is observed when the number of iterations is 99.

### Compare the results from Foundry and Hardhat

This table summarizes the gas usage for different iterations from both Foundry and Hardhat:

| Number of iterations | Gas used (Foundry) | Gas used (Hardhat) |
| -------------------- | ------------------ | ------------------ |
| 0                    | 5190               | 5168               |
| 50                   | 14740              | 14718              |
| 99                   | 24099              | 24077              |

Gas usage trends across different iterations are consistent in both Foundry and Hardhat, increasing with the number of iterations and reaching a peak at 99. Despite these similarities, slight variations in gas usage exist between the two environments at each iteration level. This stresses the importance of extending beyond local environment testing for gas usage estimation. To accurately determine the appropriate gas limit, it's recommended to conduct additional validations on the target blockchain. Setting the gas limit with a buffer is advisable to bridge gaps between local environment estimations and the actual gas usage on the target blockchain.
